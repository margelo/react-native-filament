material {
    name : Test,
    requires : [ uv0, uv1, color ],
    shadingModel : lit,
    blending : opaque,
    doubleSided : false,
    flipUV : false,

    parameters : [
        // Base Color
        { type : sampler2d, name : baseColorMap },

        // Metallic-Roughness Map
        { type : sampler2d, name : metallicRoughnessMap },

        // Normal Map
        { type : float, name : normalScale, default: -0.5 },
        { type : sampler2d, name : normalMap },
        { type : mat3, name : normalUvMatrix, precision: high }
    ],
}

fragment {
    void material(inout MaterialInputs material) {
        highp float2 uvs[2];
        uvs[0] = getUV0();
        // uvs[1] = getUV1();
        mat3 identityMatrix = mat3(1.0);

        // Configure normals
        {
            highp float2 uv = uvs[0];
            material.normal = texture(materialParams_normalMap, uv).xyz * 2.0 - 1.0;
            material.normal.y *= -1.0;
        }

        prepareMaterial(material);

        // Set base color / texture
        {
            highp float2 uv = uvs[0];
            uv = (vec3(uv, 1.0) * identityMatrix).xy;
            material.baseColor = texture(materialParams_baseColorMap, uv);
        }

        material.roughness = 0.5;
        
        // Configure metallic value (all none white pixels should be metallic):
        highp float2 uv = uvs[0];
        uv = (vec3(uv, 1.0) * identityMatrix).xy;
        vec4 mr = texture(materialParams_metallicRoughnessMap, uv);   

        // Convert the mr rgb to a greyscale value:
        float greyscale = 0.2126 * mr.r + 0.7152 * mr.g + 0.0722 * mr.b;
        // A white pixel should be metallic: 0, a black pixel should be metallic: 1
        // A whitepixel has a greyscale value of 1, thus we need to invert:
        material.metallic = 1.0 - greyscale;
    }
}
